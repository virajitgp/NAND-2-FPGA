Instruction Set:
Arithmetic & Logical:
    ADD Rd, Ra, Rb: Rd = Ra + Rb
    SUB Rd, Ra, Rb: Rd = Ra - Rb
    AND Rd, Ra, Rb: Rd = Ra & Rb
    OR Rd, Ra, Rb: Rd = Ra | Rb
    XOR Rd, Ra, Rb: Rd = Ra ^ Rb
    NOT Rd, Ra: Rd = ~Ra
    SHL Rd, Ra, Rb: Rd = Ra << Rb[3:0] (Shift Left)
    SHR Rd, Ra, Rb: Rd = Ra >> Rb[3:0] (Shift Right)

Immediate Operations
    LDI Rd, imm: Rd = imm (Load 4-bit Immediate value)
    ADDI Rd, Ra, imm: Rd = Ra + imm (Add 4-bit Immediate value)

Memory Operations:
    LOAD Rd, Ra, offset: Rd = Memory[Ra + offset] (Load from memory)
STORE Rd, Ra, offset: Memory[Ra + offset] = Rd (Store to memory)

Compare Operations:
    CMPEQ Rd, Ra, Rb: Rd = (Ra == Rb) ? 1 : 0 (Compare Equal, sets Z flag based on comparison)
    CMPLT Rd, Ra, Rb: Rd = (signed(Ra) < signed(Rb)) ? 1 : 0 (Compare Less Than)

Control Flow:
    JMP address: PC = address (Unconditional Jump)
    BZ address: if (Zero_Flag == 1) PC = address (Branch if Zero)
